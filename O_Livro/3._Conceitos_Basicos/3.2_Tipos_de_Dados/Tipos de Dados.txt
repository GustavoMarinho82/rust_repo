	Cada valor no Rust possui um tipo de dado, que informa ao Rust que tipo de dados est√° sendo especificado para que ele saiba como trabalhar com esses dados. Veremos dois subconjuntos de tipos de dados: escalar e composto (scalar and compound).

TIPOS ESCALARES
	Um tipo escalar representa um √∫nico valor. Rust tem quatro tipos escalares prim√°rios: 
- inteiros, 
- n√∫meros de ponto flutuante, 
- booleanos e 
- caracteres. 


+ INTEIROS
	Um inteiro √© um n√∫mero sem um componente fracion√°rio. Usamos um tipo inteiro no Cap√≠tulo 2, o u32tipo. Essa declara√ß√£o de tipo indica que o valor ao qual est√° associado deve ser um inteiro sem sinal (os tipos de inteiro com sinal come√ßam com i, em vez de u) que ocupa 32 bits de espa√ßo.
	Cada variante pode ser assinada ou n√£o e tem um tamanho expl√≠cito. Sinalizado e sem sinal referem-se a se √© poss√≠vel que o n√∫mero seja negativo - em outras palavras, se o n√∫mero precisa ter um sinal com ele (sinalizado) ou se ele s√≥ ser√° positivo e, portanto, pode ser representado sem sinal (sem sinal ). √â como escrever n√∫meros no papel: quando o sinal importa, um n√∫mero √© mostrado com um sinal de mais ou um sinal de menos; no entanto, quando √© seguro assumir que o n√∫mero √© positivo, ele √© mostrado sem sinal.
	Cada variante assinada pode armazenar n√∫meros de -( 2^(n-1) ) a ( 2^(n-1) )-1 inclusive, onde n √© o n√∫mero de bits que a variante usa. Assim, um i8 pode armazenar n√∫meros de -(2^7) a (2^7)-1, o que equivale a -128 a 127. Variantes sem sinal podem armazenar n√∫meros de 0 a (2^n)-1, portanto, um u8 pode armazenar n√∫meros de 0 a (2^8)-1, que √© igual a 0 a 255.
	Al√©m disso, os tipos isizee usizedependem da arquitetura do computador em que seu programa est√° sendo executado, que √© indicado na tabela como ‚Äúarch‚Äù: 64 bits se voc√™ estiver em uma arquitetura de 64 bits e 32 bits se estiver em uma arquitetura de 32 bits.

_________________________________________
|	LENGTH	|SIGNED	|UNSIGNED	|
|=======================================|
|	8-bit	|i8	|u8		|
|	16-bit	|i16	|u16		|
|	32-bit	|i32	|u32		|
|	64-bit	|i64	|u64		|
|	128-bit	|i128	|u128		|
|	arch	|isize	|usize		|
|_______________________________________|


+ PONTO FLUTUANTE
	Rust tamb√©m tem dois tipos primitivos para n√∫meros de ponto flutuante , que s√£o n√∫meros com pontos decimais. Os tipos de ponto flutuante do Rust s√£o f32 e f64, que t√™m 32 bits e 64 bits de tamanho, respectivamente. O tipo padr√£o √© f64 porque em CPUs modernas √© aproximadamente a mesma velocidade, f32 mas √© capaz de mais precis√£o. Todos os tipos de ponto flutuante s√£o assinados.

===========================================================
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
===========================================================


+ BOOLEAN
	Como na maioria das outras linguagens de programa√ß√£o, um tipo booleano em Rust tem dois valores poss√≠veis: truee false. Booleanos t√™m um byte de tamanho. O tipo booleano em Rust √© especificado usando bool.

===========================================================
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
===========================================================


+ CHAR
	O tipo de Rust char√© o tipo alfab√©tico mais primitivo da linguagem. Observe que especificamos charliterais com aspas simples, em oposi√ß√£o a literais de string, que usam aspas duplas. 

===========================================================
fn main() {
    let c = 'z';
    let z: char = '‚Ñ§'; // with explicit type annotation
    let heart_eyed_cat = 'üòª';
}
===========================================================


TIPOS COMPOSTOS
	Os tipos compostos podem agrupar v√°rios valores em um tipo. Rust tem dois tipos de compostos primitivos: tuplas e arrays.

+ TUPLAS
	As tuplas t√™m um comprimento fixo: uma vez declaradas, elas n√£o podem crescer ou diminuir de tamanho.
	Para obter os valores individuais de uma tupla, podemos usar a correspond√™ncia de padr√µes para desestruturar um valor de tupla.

===========================================================
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}
===========================================================

	Tamb√©m podemos acessar um elemento de tupla diretamente usando um ponto ( .) seguido do √≠ndice do valor que queremos acessar.

===========================================================
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
===========================================================


+ ARRAY
	Ao contr√°rio de uma tupla, cada elemento de uma matriz deve ter o mesmo tipo. Ao contr√°rio dos arrays em algumas outras linguagens, os arrays em Rust t√™m um comprimento fixo. As matrizes s√£o mais √∫teis quando voc√™ sabe que o n√∫mero de elementos n√£o precisar√° ser alterado. Por exemplo, se voc√™ estivesse usando os nomes do m√™s em um programa, provavelmente usaria uma matriz em vez de um vetor porque sabe que sempre conter√° 12 elementos.

===============================================================================
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
===============================================================================


	Voc√™ escreve o tipo de uma matriz usando colchetes com o tipo de cada elemento, um ponto e v√≠rgula e, em seguida, o n√∫mero de elementos na matriz, assim:

===========================================================
let a: [i32; 5] = [1, 2, 3, 4, 5];
===========================================================

	Aqui, i32 est√° o tipo de cada elemento. Ap√≥s o ponto e v√≠rgula, o n√∫mero 5 indica que a matriz cont√©m cinco elementos.

	Voc√™ tamb√©m pode inicializar uma matriz para conter o mesmo valor para cada elemento especificando o valor inicial, seguido por um ponto e v√≠rgula e, em seguida, o comprimento da matriz entre colchetes, conforme mostrado aqui:

===========================================================
let a = [3; 5];
===========================================================
	A matriz nomeada a conter√° 5 elementos que ser√£o todos definidos para o valor 3 inicialmente. Isso √© o mesmo que escrever, let a = [3, 3, 3, 3, 3]; mas de uma forma mais concisa.


	Um array √© um √∫nico peda√ßo de mem√≥ria de tamanho fixo conhecido que pode ser alocado na pilha. Voc√™ pode acessar elementos de um array usando indexa√ß√£o, assim:

===========================================================
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
===========================================================



RESUMO:

Inteiro: 
	let a: u8 = (0 a 255);
	let b: i8 = (-128 a 127);

Float:
	let c: f32 = 2.5;
	let d = 5.1;		//O padr√£o √© f64, s√≥ existem f32 e f64

Boolean:
	let e = true;
	let f: bool = false;

Char:
	let g = 'g';
	let h: char = 'üòª';

Tuple:
	let i: (u8, f32, char) = (1, 3.2, 'üòª');
		let one = x.0;
    		let three_point_two = x.1;
    		let cat_amoroso = x.2;

Array:
	let j: [i32; 5] = [2, 4, 6, 8, 10];	//S√≥ agrupa variaveis do mesmo tipo
		//[tipo; tamanho do array]

		let first = a[0];
		let second = a[1];