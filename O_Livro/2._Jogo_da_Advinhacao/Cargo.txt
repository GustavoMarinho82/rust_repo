É melhor ler o texto original: https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html

	Em seguida, precisamos gerar um número secreto que o usuário tentará adivinhar. O número secreto deve ser diferente a cada vez para que o jogo seja divertido de jogar mais de uma vez. Usaremos um número aleatório entre 1 e 100 para que o jogo não seja muito difícil. Rust ainda não inclui a funcionalidade de números aleatórios em sua biblioteca padrão. No entanto, a equipe Rust fornece uma randcaixa com essa funcionalidade.

	Usando uma caixa para obter mais funcionalidades
Lembre-se de que uma caixa é uma coleção de arquivos de código-fonte Rust. O projeto que estamos construindo é uma caixa binária , que é um executável. A rand grade é uma biblioteca grade , que contém código destinado a ser usado em outros programas e não pode ser executado por conta própria.

	A coordenação de caixas externas da Cargo é onde a Cargo realmente brilha. Antes de podermos escrever o código que usa rand, precisamos modificar o arquivo Cargo.toml para incluir o randengradado como uma dependência. Abra esse arquivo agora e adicione a seguinte linha abaixo do [dependencies]cabeçalho da seção que o Cargo criou para você. Certifique-se de especificar randexatamente como temos aqui, com este número de versão, ou os exemplos de código neste tutorial podem não funcionar.

=================================================
rand = "0.8.3"
=================================================

	No arquivo Cargo.toml , tudo o que segue um cabeçalho faz parte dessa seção que continua até que outra seção seja iniciada. Em [dependencies]você diz à Cargo de quais caixas externas seu projeto depende e quais versões dessas caixas você precisa. Nesse caso, especificamos o randengradado com o especificador de versão semântica 0.8.3. A Cargo entende de Versão Semântica (às vezes chamada SemVer ), que é um padrão para escrever números de versão. O número 0.8.3é, na verdade, uma abreviação de ^0.8.3, o que significa qualquer versão que esteja pelo menos 0.8.3abaixo 0.9.0.

	A Cargo considera que essas versões têm APIs públicas compatíveis com version 0.8.3, e essa especificação garante que você obterá a versão de patch mais recente que ainda será compilada com o código deste capítulo. Não é garantido que qualquer versão 0.9.0ou superior tenha a mesma API que os exemplos a seguir usam.

Agora, sem alterar nenhum código, vamos construir o projeto, conforme mostrado na Listagem 2-2.

==========================================================================
$ cargo build
    Updating crates.io index
  Downloaded rand v0.8.3
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
   Compiling rand_core v0.6.2
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
==========================================================================

Listagem 2-2: A saída da execução cargo buildapós adicionar a caixa rand como uma dependência

	Você pode ver números de versão diferentes (mas todos serão compatíveis com o código, graças ao SemVer!), linhas diferentes (dependendo do sistema operacional) e as linhas podem estar em uma ordem diferente.

	Quando incluímos uma dependência externa, o Cargo busca as últimas versões de tudo que a dependência precisa do registro , que é uma cópia dos dados do Crates.io . Crates.io é onde as pessoas no ecossistema Rust publicam seus projetos Rust de código aberto para outros usarem.

	Depois de atualizar o registro, o Cargo verifica a [dependencies]seção e baixa todas as caixas listadas que ainda não foram baixadas. Neste caso, apesar de termos listado apenas randcomo dependência, Cargo também pegou outros caixotes que randdependem para funcionar. Após baixar os crates, Rust os compila e então compila o projeto com as dependências disponíveis.

	Se você executar imediatamente cargo buildnovamente sem fazer nenhuma alteração, não obterá nenhuma saída além da Finishedlinha. O Cargo sabe que já baixou e compilou as dependências, e você não alterou nada sobre elas em seu arquivo Cargo.toml . O Cargo também sabe que você não alterou nada em seu código, portanto, também não o recompila. Sem nada para fazer, ele simplesmente sai.

	Se você abrir o arquivo src/main.rs , fizer uma alteração trivial, salvá-lo e compilar novamente, você verá apenas duas linhas de saída:

==========================================================================
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
==========================================================================

	Essas linhas mostram que o Cargo apenas atualiza a compilação com sua pequena alteração no arquivo src/main.rs . Suas dependências não foram alteradas, então o Cargo sabe que pode reutilizar o que já baixou e compilou para elas.

	Garantindo Builds Reprodutíveis com o Arquivo Cargo.lock
O Cargo tem um mecanismo que garante que você possa reconstruir o mesmo artefato toda vez que você ou qualquer outra pessoa compilar seu código: O Cargo usará apenas as versões das dependências especificadas até que você indique o contrário. Por exemplo, digamos que na próxima semana a versão 0.8.4 do randengradado seja lançada, e essa versão contém uma correção de bug importante, mas também contém uma regressão que quebrará seu código. Para lidar com isso, Rust cria o arquivo Cargo.lock na primeira vez que você executa cargo build, então agora temos isso no diretório guessing_game .

	Quando você cria um projeto pela primeira vez, o Cargo descobre todas as versões das dependências que atendem aos critérios e as grava no arquivo Cargo.lock . Quando você construir seu projeto no futuro, o Cargo verá que o arquivo Cargo.lock existe e usará as versões especificadas lá em vez de fazer todo o trabalho de descobrir as versões novamente. Isso permite que você tenha uma compilação reproduzível automaticamente. Em outras palavras, seu projeto permanecerá em 0.8.3até você atualizar explicitamente, graças ao arquivo Cargo.lock . Como o arquivo Cargo.lock é importante para compilações reproduzíveis, ele geralmente é verificado no controle de origem com o restante do código em seu projeto.

Atualizando uma caixa para obter uma nova versão
	Quando você deseja atualizar um engradado, Cargo fornece o comando update, que ignorará o arquivo Cargo.lock e descobrirá todas as versões mais recentes que atendem às suas especificações em Cargo.toml . O Cargo então gravará essas versões no arquivo Cargo.lock . Caso contrário, por padrão, o Cargo procurará apenas versões maiores 0.8.3e menores que 0.9.0. Se a randcaixa lançou as duas novas versões 0.8.4e 0.9.0você veria o seguinte se executasse cargo update:

==========================================================================
$ cargo update
    Updating crates.io index
    Updating rand v0.8.3 -> v0.8.4
==========================================================================

	A carga ignora a 0.9.0liberação. Neste ponto, você também notaria uma mudança em seu arquivo Cargo.lock , observando que a versão do randengradado que você está usando agora é 0.8.4. Para usar a randversão 0.9.0ou qualquer versão da 0.9.xsérie, você teria que atualizar o arquivo Cargo.toml para ficar assim:

==========================================================================
[dependencies]
rand = "0.9.0"
==========================================================================

	Na próxima vez que você executar o cargo build, Cargo atualizará o registro de caixas disponíveis e reavaliará suas randnecessidades de acordo com a nova versão que você especificou.

	Há muito mais a dizer sobre a Cargo e seu ecossistema , que discutiremos no Capítulo 14, mas, por enquanto, é tudo o que você precisa saber. O Cargo facilita muito a reutilização de bibliotecas, de modo que os Rustaceans podem escrever projetos menores que são montados a partir de vários pacotes.